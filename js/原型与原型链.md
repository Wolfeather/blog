## 前言

为了图自己方便，我一般会执行以下代码
```js
const log = console.log
```

## 原型
原型分为两种：显式原型和隐式原型
- 显式原型：指每个函数声明时，js内部为函数添加的`prototype`属性。
- 隐式原型：指每个实例对象被创建时，js内部为实例添加的`__proto__`属性。

```js
function Fn(){
}
log(Fn.prototype)
// { constructor: Fn()
//   __proto__: Object }
let f = new Fn()
log(f)
// Fn{}
// - __proto__ : {
// 	- constructor: Fn()
// 	- __proto__: Object}
```

不难看出，
- Fn.prototype：值是一个对象，对象中有2个值：
  - constructor：指向函数Fn本身。 =>得到结论：函数的prototype与函数本身相互引用。
  - `__proto__`：指向Object的原型。 => 因为Fn.prototype是Object的实例对象。所以会有`__proto__`属性。
- `f.__proto__`：值与Fn.prototype一模一样。

所以能得出结论：

```js
function Fn() {
	// 创建函数时，自动创建原型属性 值为对象，且有属性constructor指向函数自己，也就是this
	// this.prototype = new Object()
	// this.prototype.constructor = this
}

var f = new Fn()
// 创建实例对象时，自动执行
// f.__proto__ = Fn.prototype
log(f.__proto__ === Fn.prototype) // true

```



### 构造函数中的方法和原型中的方法

根据原型的规则：当代码中访问f.a时，程序会先在f实例对象中找a属性，如果没找到，就去a的原型上找。
那么属性写在构造函数中和原型方法中有什么区别呢？


```js
function Fn() {
	this.f1 = function (){
		log('f1')
	}
}
Fn.prototype.f2 = function (){
	log('f2')
}
let a = new Fn(), b = new Fn()
log(a.f1 === b.f1)	// false
log(a.f2 === b.f2)	// true
```

- a.f1在a对象内部，b.f1也在b对象内部。他们是两个除了地址，其他都一样的方法。
- 而a和b本身是没有f2方法的，所以找到了`a.__proto__.f2`和`b.__proto__.f2`。而他俩指向的是同一个地址。所以`a.f2===b.f2`是true。

### 总结 
所以当我们写构造函数的公共方法时，最好写在原型上。这样公共方法只用创建在方法的原型就够了，可以避免多次创建方法，从而提高效率。

## 原型链
在上一节有提到，当访问f.a时，程序会先在f自身找，如果没找到，则去`a.__proto__`上找，如果还没找到，就去`a.__proto__.__proto__`上找，直到`a.__proto__......__proto__`为空。
而这个`a.__proto__......__proto__`，就被我们称为了原型链。

### 增长原型链
那我们该如何增长原型链呢？
其实道理很简单 让新的实例对象`b.__proto__` 指向实例a。这样b的原型链就比a多了一块。
```js

function Fa(){}
function Fb(){}
// 换句话说就是要让 b.__proto__ = a => b.__proto__ = Fa的实例对象 => b.__proto = new Fa()
// 但是我们不能直接操作 b.__proto__ 
// 因为一开始我们就验证了  b.__proto__是由b的构造函数Fb来的  所以我们给Fb的显示原型重新赋值就好了
Fb.prototype = new Fa()
let b = new Fb()

log(b.__proto__ === Fb.prototype) // true
log(b.__proto__.__proto__ === Fa.prototype) // true
log(b.__proto__.__proto__.__proto__ === Object.prototype) // true
```
### 原型链关系图

这时候就祭出这张图了 

![原型链1](D:\Project\blog\imgs\原型链1.png)



### 进阶

上面我们将实例对象的原型链分析清除了，接下来我们接着思考。JavaScript中，**所有方法都是对象**，怎么理解这一句话？

```js
log(Fa.__proto__) // [native code]
// =>函数也有隐式原型 
log(Fa.__proto__ === Function.prototype) // true
// =>说明 函数的隐式原型是 Function的原型
// =>说明 每个声明的函数都是Function的实例对象
log(Function.prototype.__proto__ === Object.prototype) // true
// =>Function的原型是一个对象(Object实例对象) 所以__proto__也指向Object的原型

// 函数都有隐式原型 那Function和Object呢？
log(Function.__proto__ === Function.prototype) // true
log(Object.__proto__ === Function.prototype) // true
// Function和Object也有隐式原型 指向Function自己的原型

```

最后我们可以得出结论：

只要是函数对象都有`__proto__`属性，都指向Function的原型(包括Object和Function自己)

只要是对象`__proto__`属性，最终的尽头都是Object的原型






